%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------
\chapter{Arquitectura y Tecnologías empleadas}

En esta sección se van a exponer detalles técnicos del desarrollo que sirva para completar todos aquellos puntos que no se tratan en los capítulos de los otros juegos, pero que han sido necesarios para el desarrollo del proyecto.

%-------------------------------------------------------------------
\section{Realidad aumentada}
%-------------------------------------------------------------------
\label{cap4:sec:ra}

Vuforia es el framework que hemos utilizado para hacer toda la parte de RA. Este tiene una magnífica integración con Unity 3D y facilita muchísimo su desarrollo.

Para generar RA, Vuforia superpone a la imagen tomada por la cámara de, en este caso, nuestro Smartphone, cualquier modelo en tres dimensiones que queramos sobre la posición de un Image Target (u otro marcador) que le hayamos indicado. De esta manera, tenemos un ``fondo'' con la imagen tomada por la cámara, con modelos en tres dimensiones ``por encima''. Además, nos mantiene siempre los objetos de tres dimensiones en el mismo punto del espacio, por lo que si movemos nuestra cámara, cambiará la perspectiva desde donde vemos el objeto, pudiendo girar alrededor de éste. El comportamiento puede ser diferente, dependiendo de cómo lo hayamos configurado (podemos hacer que el objeto persista aun que perdamos de vista el detector).

Vuforia proporciona paquetes para trabajar directamente con el SDK de Android o el de iOS, así como para Unity3D. Utilizando Unity3D podemos exportarlo después a una aplicación de Android o iOS también, aunque no quedaría de una manera tan ``pulida'' como desarrollándola directamente con el SDK del sistema operativo deseado. Nosotros hemos decidido utilizar el paquete para Unity3D, ya que es un motor de videojuegos y los tres teníamos unos conocimientos básicos en desarrollo con Unity, además de que nos permite exportar después el proyecto al sistema operativo que quisiéramos..

\section{Desarrollo de videojuegos con Unity}
\label{cap4:sec:unity}

Unity funciona con algo a lo que han llamado escenas, que son diferentes situaciones o niveles del juego \cite{Unity3d}. En toda escena hay una jerarquía de objetos que la componen, y de cada objeto pueden colgar otros objetos, además de que se pueden añadir (por medio de código programable) otros objetos a esa jerarquía de manera dinámica. Todos los objetos de Unity tienen una serie de componentes, el más básico sería el de su situación en las tres dimensiones (o dos), su escala y su rotación con respecto a los tres planos. Estos componentes permiten configurar los objetos de manera sencilla, encapsulando funcionalidades. Esta forma de ``componer'' los objetos no es casual: es la más utilizada en programación de videojuegos.

La programación o arquitectura basasada en componentes tiene como principal característica tener más abstracción que la basada en objetos. ``Cada componente es un elemento de un sistema que ofrece un servicio predefinido , y es capaz de comunicarse con otros componentes'' \cite{progcomponentes}.

 Además, Unity cuenta con una extensísima comunidad de desarrolladores, así como tutoriales, guías, dudas resueltas\ldots{} solo con los tutoriales que proporciona la propia gente de Unity podemos hacer un sencillo juego casi de cada uno de los tipos más comunes de juegos.

Unity nos proporciona por defecto el cálculo de colisiones entre objetos, gravedad, eventos de teclado o ratón... en pocos minutos podemos hacer cosas sencillas pero que con otras herramientas, o programándolo directamente a mano con un lenguaje de programación cualquiera como podría ser Java o C++, nos llevarían bastante más tiempo.

Los scripts los podemos escribir en C#, Boo o un lenguaje ``parecido'' a JavaScript. Nosotros hemos decidido utilizar C\#, ya que era la opción que más nos convencía por varias razones:

\begin{itemize}
\item{Es más eficiente. Los tres teníamos conocimientos previos de Java, y C\# es muy similar a Java en cuanto a sintaxis.}
\item{Es el más usado por la comunidad.}
\end{itemize}

Todos los Scripts utilizados en Unity heredan de la clase MonoBehaviour, la cual permite a estos scripts integrarse con la ejecución interna de Unity. Toda clase que herede de MonoBehaviour tiene los métodos Start (), Awake (), Update (), FixedUpdate (), y OnGUI (), entre otros. 

Éstos se ejecutan en diferentes momentos del juego.

\begin{itemize}
\item{Awake (): el primer método al que se llama, antes incluso de que el objeto asociado esté habilitado en la escena. Se utiliza para inicializaciones o referencias entre scripts.}

\item{Start (): se ejecuta después de Awake (), justo antes del primer Update () y después de que se active el objeto.}

\item{Update (): se ejecuta en cada frame. Esto hace que dependa del procesador y del equipo donde se ejecuta. Se usa para actualizaciones comunes como mover objetos no físicos, recoger entrada del usuario\ldots{}}

\item{FixedUpdate (): el intervalo entre una ejecución y otra es consistente y siempre el mismo. Se utiliza para actualizaciones cómo ajustar objetos físicos.}

\item{OnGUI (): se utiliza para gestionar y renderizar eventos de la Interfaz Gráfica de Usuario (Graphic User Interface, GUI). Sólo es llamada si el objeto está habilitado.}
\end{itemize}

\subsection{Integración de Unity con Vuforia}
\label{cap4:sub:unityvuforia}

Vuforia nos proporciona un paquete de extensión de Unity 3D el cual debemos importar para trabajar. Éste paquete contiene diferentes prefabs (objetos ya construidos) que nos harán la tarea muy sencilla.

Lo que debe tener toda aplicación de RA hecha con Vuforia y Unity 3D es una ARCamera (cámara de RA). A ésta hay que indicarle el product key que nos da Vuforia desde su portal para desarrolladores, además de ésto, se le indicará el paquete de targets propios . Es la unidad mínima de desarrollo de RA con Vuforia.

Una vez hecho esto, tendremos diferentes opciones para lanzar los objetos de RA, que deben colgar en la jerarquía de Unity de cualquiera de los siguientes prefabs \cite{vuforia}:

\begin{itemize}
\item{Frame Markers: Son marcadores muy sencillos que son proporcionados por la gente de Vuforia en su paquete. Se pueden utilizar para calibrar la cámara, pero no tienen una gran calidad a la hora de ser detectados. Son lo más sencillo para comenzar una aplicación de prueba.}

\item{Image Targets: Imágenes propias del desarrollador. Funcionan como los Frame Markers, pero éstas deben ser importadas desde un paquete generado por el portal de desarrolladores de Vuforia, el cual nos indicará la calidad de esa imagen para ser detectada.}

\item{Multi-Targets: Son varios ImageTargets que representan las diferentes caras de un prisma en tres dimensiones.}

\item{Cylinder Targets: ImageTarget que envuelve un cilindro, para representar, por ejemplo, una botella u otro objeto similar.}

\item{Text Recognition: Nos permite detectar textos, ya sean del diccionario proporcionado por Vuforia de palabras en inglés (más de 100.000 palabras diferentes) o de uno creado por nosotros mismos.}

\item{Object Recognition: Sirve para configurar un objeto en tres dimensiones que no sea ninguno de los anteriores.}

\item{Smart Terrain: Permite reconstruir el entorno del usuario de la aplicación en tres dimensiones (Fig: \ref{fig:smartterrain}).}
\end{itemize}

\figura{Tfg/smartTerrain.png}{width=.5\textwidth}{fig:smartterrain}
		{Ejemplo de aplicación con Smart Terrain}

Con cualquiera de estos objetos, la funcionalidad por defecto (que podemos modificar creando nuestras propias clases que hereden de las que nos da Vuforia) es que al detectarse (ya sea un ImageTarget, un Text Recognition, etcétera) se comenzarán a mostrar todos los objetos que cuelguen de él en la jerarquía de Unity.

\section{Escenas intermedias}
%-------------------------------------------------------------------
\label{cap4:sec:intermedias}

Antes de cada minijuego, como nexo de enlace entre ellos, se ha establecido una escena intermedia donde un humanoide nos pone en situación antes de cada misión y nos sitúa acerca de cómo se ha llegado a dicha situación y a dónde debemos ir para resolverla.

\subsection{SALSA with Random Eyes}
\label{cap4:sub:salsa}

Gracias al paquete de Unity de animación por voz, SALSA lip sync, el proceso de sincronizar el audio con la animación del discurso del modelo ha sido algo muy sencillo \cite{salsa}. Dicha animación consta de tres componentes:

\begin{itemize}
\item{El modelo, que en este caso era un prefab que venía configurado por defecto para soportar el componente de audio y de enfoque aleatoria.}

\item{Componente de animación de los músculos faciales, al cual se le asigna un conjunto de audios de tal forma que la cara del modelo se articula de forma sincronizada con el audio proporcionado. El componente viene configurado para que el audio que le proporcionamos al modelo pueda ser interpretado por este con más o menos énfasis o con diferentes estados de ánimo.}

\item{Random eyes es un componente que, asignado al modelo, articula sus ojos de tal forma que definiendo unos puntos objetivo, alterna y gesticula mirando a los diferentes objetivos a lo largo de la animación del objeto.}
\end{itemize}

\subsection{VozMe MP3 generator}
\label{cap4:sub:vozme}

Además del modelo utilizado, también hubo que crear los audios que narran el hilo argumental de nuestro juego. Para esta tarea, se generarón los audio con la herramienta vozme.com \cite{vozme} que convierte a mp3, con una voz un ``robótica'', un texto dado.

\section{Persistencia de puntuaciones}
%-------------------------------------------------------------------
\label{cap4:sec:puntuaciones}

Al finalizar el juego, el usuario puede almacenar su puntuación, y ver el ranking de estas. Este sistema se hizo para enlazar el juego con lo que es un servicio web, ya que nos parecía una práctica interesante el hacer uso de la parte cliente que nos ofrece Unity para comunicarnos con servicios web. Se han implementado ambas partes en este caso, tanto el lado cliente que consume los servicios en Unity, como el lado del servidor, en el que se ha implementado un sistema de gestión de usuarios con una sencilla api REST en PHP, haciendo uso del framework Symfony 2.

\subsection{Symfony}
\label{cap4:sub:symfony}

La arquitectura cliente-servidor es un modelo de aplicación distribuida en el que las tareas se reparten entre los proveedores de recursos o servicios, llamados servidores, y los demandantes, llamados clientes. En nuestro caso, Unity se consideraría el cliente, y es quién realiza peticiones a los servicios que tenemos implementados, el servidor, quien le da respuesta.

Por otro lado, un servicio web consiste en una petición del cliente, de tal forma que a través del protocolo http (describe la forma de comunicarse entre el cliente y el servidor), en función de la acción que va a realizar nuestro servidor, la petición se envía de una forma u otra. Los tipos de petición que contempla el protocolo http son POST, GET, PUT y DELETE, aunque con el paso del tiempo se han ido ampliando, estos son los principales. En nuestra aplicación solo se van a utilizar POST, para realizar una acción cuyo propósito es el de añadir un elemento a nuestra base de datos y GET,que le proporcionará al usuario una lista con las puntuaciones de los usuarios.

La comunicación entre Unity (cliente) y Symfony (servidor) es a través del formato de datos json, de tal forma que con Unity se interpretan estos datos y se muestran en pantalla al pedir la lista de usuarios al servidor, haciendo la correspondiente petición http a través del servicio que proporciona Symfony para devolver dichos datos. De igual forma, pero en el otro sentido, Unity los manda al servidor para dar de alta una nueva puntuación, y Symfony, lo interpreta para almacenar esos datos.

El lado del cliente (Unity), está implementado con los scripts de Unity escritos con C#, y en el lado del servidor, se utiliza PHP con un Symfony cmmo framework, que facilita mucho el desarrollo.

Los servicios que se implementaron son el servicio POST, /api/user para añadir una puntuación, y el servicio GET /api/users.json para obtener la lista de puntuaciones d elos usuarios.

\figura{Tfg/cliente-servidor.jpg}{width=.5\textwidth}{fig:cliente-servidor}
		{Funcionamiento cliente servidor}


Para el desarrollo con symfony de nuestra API REST se tuvieron en cuenta los siguientes puntos:

\begin{itemize}
\item{Base de datos: Se genera una base de datos SQL con una sola tabla, la de usuarios y los campos que deseabamos guardar: id, nombre y puntuación.}

\item{Operaciones: Para la parte REST; los servicios, solo pueden realizar las operaciones de leer y crear nuevos usuarios. En el panel de administración, se pueden realizar las CRUD, crear un nuevo usuario, leer los usuarios y ver el usuario en detalle, actualizar y eliminar.}

\item{REST: las operaciones de la API son, de tipo GET /api/users.{[}json \textbar{} xml{]} para obtener un listado de los usuarios y sus puntuaciones en uno de los formatos especificados. Y para guardar la puntuación de un usuario, de tipo POST /api/users dónde se les manda, en el body de la petición, la puntuación del usuario y el nombre de este.}

\item{Seguridad: De lado del servidor, Symfony~nos provee de un sistema de seguridad basado en tres factores; la dirección a la que se accede, la autenticación para acceder a ella y una vez autenticado, el rol que tiene dicho usuario para poder acceder. En nuestro caso hay dos usuario. ``admin'', con el rol de administrador, que le permite entrar tanto en el panel de administración, como hacer uso de la api. Y ``api\_user'', un usuario cuyo rol solo le permite usar los servicios web. El tipo de autenticación es a través de Basic auth. Consiste en añadir un campo en el header~con la clave ``Authorization'' y como valor, la palabra ``Basic'' concatenada y separados por un espacio con la combinación de ``username:password'' codificada en Base64.}
\end{itemize}

La implementación del sistema de persistencia se compone de dos partes, la parte del cliente, dónde se consumen los servicios web; y la parte del servidor, donde se configura el sistema.

El lenguaje utilizado para implementar la parte del lado del Servidor es PHP. Sobre este lenguaje se utiliza un framework de desarrollo llamado Symfony, que facilita mucho la tarea de construir este tipo de sistemas. Symfony hace uso de trabajar basada en el Modelo Vista Controlador y el flujo de trabajo sobre este framework consiste en simplificarte, bajo esta arquitectura, un montón de procedimientos y líneas de código que se repiten constantemente en este tipo de software.

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
